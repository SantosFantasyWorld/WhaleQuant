# Pandas 简介

## 用 Pandas 组织财务数据

Pandas是一款主要用于组织、操作和分析数据的Python库。虽然它功能丰富，但需要一定的基础。为了帮助您适应这种学习曲线，我们将在本课程中花些时间介绍Pandas，并讲解它在财务分析中的作用。在本课程中，您将学习如何使用Pandas存储和访问数据，并介绍基本的Pandas对象作为构建块。Pandas以表格形式组织数据，类似于电子表格的方式，但由于Pandas非常强大，您可以比在电子表格中更轻松地执行复杂的分析。鉴于Pandas和电子表格之间的相似之处，我们将从在电子表格中收集数据并对其进行分析开始，而这个例子恰好可以证明为什么要Pandas。

### 表格形式的数据

当我们在 Excel 中打开 qan_prc_2020.csv 文件时，我们会看到一个包含以下数据的电子表格：

|      | a          | b      | C      | d      | e      | f         | g        |
| ---- | ---------- | ------ | ------ | ------ | ------ | --------- | -------- |
| `1`  | 日期       | open   | high   | low    | close  | adj close | volume   |
| `2`  | 2020-01-02 | 7.1400 | 7.2100 | 7.1200 | 7.1600 | 6.9852    | 4980666  |
| `3`  | 2020-01-03 | 7.2800 | 7.3100 | 7.1600 | 7.1900 | 7.0145    | 2763615  |
| `4`  | 2020-01-06 | 7.0100 | 7.0300 | 6.9100 | 7.0000 | 6.8291    | 7859151  |
| `5`  | 2020-01-07 | 7.2300 | 7.2550 | 7.0800 | 7.1000 | 6.9267    | 7589056  |
| `6`  | 2020-01-08 | 7.0500 | 7.0800 | 6.7600 | 6.8600 | 6.6925    | 13449760 |
| `7`  | 2020-01-09 | 6.9700 | 7.0000 | 6.9000 | 6.9500 | 6.7803    | 6173211  |
| `8`  | 2020-01-10 | 6.9900 | 7.0600 | 6.9600 | 7.0000 | 6.8291    | 4450193  |
| `9`  | 2020-01-13 | 6.9800 | 7.0600 | 6.9800 | 7.0200 | 6.8486    | 3842992  |
| `10` | 2020-01-14 | 7.0900 | 7.1500 | 7.0800 | 7.1100 | 6.9364    | 4958613  |
| `11` | 2020-01-15 | 7.1700 | 7.2000 | 7.0200 | 7.0400 | 6.8681    | 10472071 |
| `12` | 2020-01-16 | 7.0400 | 7.0700 | 7.0200 | 7.0700 | 6.8974    | 10728336 |
| `13` | 2020-01-17 | 7.1200 | 7.1500 | 7.1000 | 7.1500 | 6.9755    | 9619822  |

上述描述了表格形式的数据，通常以行和列的形式呈现，形成一个二维矩阵。不同的列通常包含不同的数据类型。在这个例子中，我们有日期数据（A列）、开盘股价（B列）、当天股票最高价（C列）和最低价（D列）、股票在市场收盘时的价格（E列），根据股票拆分、股息和其他事件调整的收盘价（F列），以及当天的总交易量（G列）。

表格中的每一行都会跨越多个列链接单元格。在这个例子中，A列提供了日期信息。我们可以根据A列中提供的日期，确定每一行中的数据所代表的日期。例如，在第7行中，B、C、D和E分别对应于A列中的日期，即2020年1月9日。

### 如果excel 能处理数据，那为什么要用pandas呢？

Pandas库的优点在于提供了灵活性和强大功能的结合。然而，这些优点的获得是有代价的，至少在最初阶段，需要面对复杂性的挑战。因此，需要通过练习来适应Pandas。

但是，即使是在最基本的层面上，比如在表格中查找数据，Pandas比Excel具有显着的优势。我们已经习惯了电子表格程序，我们从来没有质疑它们的工作原理或者它们是否可以改进。

Excel中的电子表格迫使我们在所有情况下都按字母和数字访问数据，这不是特别直观或用户友好。与之相比，“D列第5行的单元格”这样的描述并不如“2020年1月15日的开盘价”直观。在Pandas中，我们可以使用命名索引来查找值。例如，如果我们想要特定日期的开盘价数据，则使用元组(open_price, 2020-01-15)来查询比使用(column D, row 5)更直观。

我们将采用以下策略从电子表格过渡到Pandas。我们将从一个非常简单的任务开始，计算一个时间窗口内股票的平均收盘价。我们将通过三种不同的方式解决这个问题：

首先，我们将使用Excel来计算这个平均值。这是一个基线，因为Excel和Pandas都依赖相似的元素来组织和操作表格数据。

接下来，我们将使用Python的标准库来执行相同的任务。这将展示一些相对于Excel的优势，但仍有改进的余地。

最后，我们将讨论Pandas及其相对于Excel和Python标准库的优势。

### 计算 2020 年第二周 Qantas 平均价格：Excel

要计算Qantas在2020年第二周的平均价格，我们需要执行以下步骤：

1.确定带有日期的列：A列。

2.确定A列中与日期从“2020-01-06”到“2020-01-10”相对应的相关行：第4到第8行。

3.确定具有收盘价的列（上面称为“收盘价”）：E列。

4.定义相关数据项的切片（或范围）为E4:E8

5.通过在Excel中输入=average(E4:E8)将函数AVERAGE应用于切片E4:E8。

这种方法可以实现，但在Excel中进行这样的计算有一些缺点。例如，如果基础源数据中列的顺序发生变化，会发生什么情况？如果我们添加数据并将行向上或向下移动怎么办？如果我们想要不同的日期范围怎么办？如果我们想计算每周的平均值怎么办？我们不能简单地将平均单元格向下复制一行，因为这会给我们周二到周一的平均值，而不是周一到周五的平均值。另外，如何处理节假日和其他非交易日？如果我们有数十万个观察结果会怎么样？

我们可以使用不同的标签（例如，“收盘价”等）而不是A、B等来引用列，使用直接的日期引用行。最终，我们希望通过包含的信息来引用列和行，例如计算['收盘价']（'2020-01-06':'2020-01-10'”的平均值。

### 计算 2020 年第二周 Qantas 平均价格：Python 标准库

现在，让我们看看如何使用 Python 的标准库来计算这个平均值。

~~~
# ---------------------------------------------------------------------------- 
#   The dates and prices lists
# ---------------------------------------------------------------------------- 
dates = [
  '2020-01-02', 
  '2020-01-03',
  '2020-01-06',
  '2020-01-07',
  '2020-01-08',
  '2020-01-09',
  '2020-01-10',
  '2020-01-13',
  '2020-01-14',
  '2020-01-15',
  ]

# Close price
prices = [
  7.1600, 
  7.1900,
  7.0000,
  7.1000,
  6.8600,
  6.9500,
  7.0000,
  7.0200,
  7.1100,
  7.0400,
  ]

# ---------------------------------------------------------------------------- 
#   Indexing using lists
# ---------------------------------------------------------------------------- 

# The `start` variable will hold the first index in the slice and the `end`
# variable will hold the last index in the slice. Remember that the `index`
# list method will return the position of the element in the list, starting at
# 0. In this case, `start` will be set to 2 and `end` will be set to 6.

# Remember to uncomment the statements below and complete the part with '?' 
start  = '?'
end  = '?'
#print(start, end)                   

# Now, slice the `prices` list. 
# Remember that slices do not include endpoints
prcs_w1  = '?'

# Finally, calculate the average of the prices in the slice
avgprc  = '?'
#print(avgprc)                       


# ---------------------------------------------------------------------------- 
#   Indexing using dictionaries
# ---------------------------------------------------------------------------- 
prc_dic = {
  '2020-01-02': 7.1600, 
  '2020-01-03': 7.1900,
  '2020-01-06': 7.0000,
  '2020-01-07': 7.1000,
  '2020-01-08': 6.8600,
  '2020-01-09': 6.9500,
  '2020-01-10': 7.0000,
  '2020-01-13': 7.0200,
  '2020-01-14': 7.1100,
  '2020-01-15': 7.0400,
  }

# Get the price on '2020-01-13', in this case, 7.02
x  = '?'
#print(f'The price on 2020-01-13 is {x}')    


# Try the following... it will not work because we cannot slice dictionaries
#prc_dic['2020-01-02':'2020-01-13']          # Raises Exception
~~~

#### 如果使用list

为了更好地说明，我们将不使用所有的数据，而是只使用 Date 和 Close 列的前十个观察值。lec_avgs_example.py模块定义了两个列表，分别是日期和价格。

~~~
# ---------------------------------------------------------------------------- 
#   The dates and prices lists
# ---------------------------------------------------------------------------- 
dates = [
  '2020-01-02', 
  '2020-01-03',
  '2020-01-06',
  '2020-01-07',
  '2020-01-08',
  '2020-01-09',
  '2020-01-10',
  '2020-01-13',
  '2020-01-14',
  '2020-01-15',
  ]

# Close prices
prices = [
  7.1600, 
  7.1900,
  7.0000,
  7.1000,
  6.8600,
  6.9500,
  7.0000,
  7.0200,
  7.1100,
  7.0400,
  ]
~~~

为了计算从“2020-01-06”到“2020-01-10”的平均价格：

1. 我们可以使用日期列表找到第一个和最后一个日期的索引。列表方法index(item)接受一个参数item，Python将搜索列表以找到第一个元素等于item的值，并返回其从零开始的索引位置。
2. 我们可以使用切片将价格子集化以对这些日期的价格进行计算。
3. 我们可以通过将所有元素的总和除以元素数量来计算平均值。Python的sum(iterable)函数可以用于将浮点数列表中的值相加。

为了实现上述步骤，可以将以下内容添加到lec_avgs_example.py中，然后运行该模块。要避免复制和粘贴，而是自己键入每个语句。

~~~
# Remember to uncomment the statements below and complete the part with '?' 
start = dates.index('2020-01-06')   
end = dates.index('2020-01-10')     
print(start, end)                   

# Now, slice the `prices` list. 
# Remember that slices do not include endpoints
prcs_w1 = prices[start:end+1]       

# Finally, calculate the average of the prices in the slice
avgprc = sum(prcs_w1)/len(prcs_w1)  
print(avgprc) 
~~~

这段文字表达的是，在Python中使用列表对象进行数据分析类似于我们在Excel中所做的。对于简单的任务，列表对象可以胜任。然而，在进行严肃的数据分析（特别是财务数据分析）时，列表对象并不是理想的选择。这有很多原因，包括可读性、同步性和性能方面的考虑。

##### 可读性

我们提到直接使用日期来选择价格会更方便。在上面的示例中，我们首先定义了起始值和结束值，但我们也可以直接执行以下操作：

~~~
# Select the price on '2020-01-06'
prices[dates.index('2020-01-06')]

# Select the prices for the first week of 2020
prices[dates.index('2020-01-06'):dates.index('2020-01-10')+1]
~~~

可以看见，可读性成为了一个问题。 prices[dates.index('2020-01-06'):dates.index('2020-01-10')+1] 不仅难以阅读，而且很容易忘记包含“+1”，以确保捕获最后一天！

##### 同步问题

对于列表，日期列表中每个日期的索引必须与价格中该日期的价格索引相匹配。但是，日期列表和价格列表之间没有内在的联系。例如，日期列表可以按时间顺序排序，而价格列表可以按值升序排序。因此，作为程序员，确保每个列表中元素的顺序保持同步的责任落在您身上。您可能会意外地从日期列表中删除了一个观察值，但没有在价格列表中这样做。如果发生这种情况，索引将不正确。

##### 性能问题

Python 的列表对象旨在处理各种类型的对象，而没有专为处理数字数据而优化。因此，它们在处理大量数字数据时可能不太有效率。为了解决这个问题，Python 的 NumPy 库提供了对数字计算的优化支持，这对于金融等领域的数值计算非常有用。Pandas 将 NumPy 库集成进来，这意味着使用 Pandas 处理大量数据时，可以获得比使用纯 Python 列表更高的性能和效率。

##### 开放问题

**如果使用字典进行读取数据会怎么样？**



## Pandas 的 Series, Indexes和DataFrames

上一节介绍了使用 Excel 和 Python 标准库进行简单任务的问题，这些工具可能会强制我们以不太直观的方式处理数据。Pandas解决了这些问题。Pandas允许我们使用标签进行自然的查找，使我们的“列”保持同步，并且允许对复杂的计算进行简单的切片，使得处理数据更加轻松、灵活和高效。本节将介绍Pandas中的主要对象：DataFrames、Series和Indexes。理解这些对象之间的关系以及它们的用途是很重要的，因为了解Pandas中信息的逻辑和层次结构是从中获得最大收益的关键。同时，我们还将形式化表格数据的规范化透视图，这为Pandas对象提供了一个良好的基础。

### 从规范的角度

本文提出了一种不同于 Excel 中列和行互换的数据组织方式，即以列为数据集的主要构建块。每列包含特定类型的数据，列不混合数据，列索引是唯一标识每一列的标签。行链接跨列的数据，行索引也是一组与列索引分开的标签，行索引使我们能够识别任何列中的元素。在这种数据组织方式中，列名和行号可以作为引用数据的标签，而不是 Excel 中的列字母和行数字。Pandas 可以更方便、更直观地访问数据。

在电子表格中，数据以列为单位进行组织。每一列包含特定类型的数据，不会混合不同类型的数据。列的索引是唯一标识每一列的标签，通常是字母。虽然第一行通常包含列中包含的数据的描述性名称，但通常不能通过此名称引用单元格。Excel中的行索引标签只是数字，通常用于识别行中的元素，例如股票价格的观察日期。然而，Excel很难通过此信息引用观察结果。相反，我们必须使用行索引：行号。与Excel不同，Pandas让我们使用列名访问数据，更加直观方便。行索引也是一组与列索引分开的标签，使我们能够识别任何列中的元素。

让我们使用我们的 Qantas 股票价格数据示例表，看看 Excel 如何符合上述规范的观点：

|      | A          | B      | C      | D      | E      | F         | G        |
| ---- | ---------- | ------ | ------ | ------ | ------ | --------- | -------- |
| `1`  | Date       | Open   | High   | Low    | Close  | Adj Close | Volume   |
| `2`  | 2020-01-02 | 7.1400 | 7.2100 | 7.1200 | 7.1600 | 6.9852    | 4980666  |
| `3`  | 2020-01-03 | 7.2800 | 7.3100 | 7.1600 | 7.1900 | 7.0145    | 2763615  |
| `4`  | 2020-01-06 | 7.0100 | 7.0300 | 6.9100 | 7.0000 | 6.8291    | 7859151  |
| `5`  | 2020-01-07 | 7.2300 | 7.2550 | 7.0800 | 7.1000 | 6.9267    | 7589056  |
| `6`  | 2020-01-08 | 7.0500 | 7.0800 | 6.7600 | 6.8600 | 6.6925    | 13449760 |
| `7`  | 2020-01-09 | 6.9700 | 7.0000 | 6.9000 | 6.9500 | 6.7803    | 6173211  |
| `8`  | 2020-01-10 | 6.9900 | 7.0600 | 6.9600 | 7.0000 | 6.8291    | 4450193  |
| `9`  | 2020-01-13 | 6.9800 | 7.0600 | 6.9800 | 7.0200 | 6.8486    | 3842992  |
| `10` | 2020-01-14 | 7.0900 | 7.1500 | 7.0800 | 7.1100 | 6.9364    | 4958613  |
| `11` | 2020-01-15 | 7.1700 | 7.2000 | 7.0200 | 7.0400 | 6.8681    | 10472071 |
| `12` | 2020-01-16 | 7.0400 | 7.0700 | 7.0200 | 7.0700 | 6.8974    | 10728336 |
| `13` | 2020-01-17 | 7.1200 | 7.1500 | 7.1000 | 7.1500 | 6.9755    | 9619822  |

Excel 训练我们以特定方式查找数据。  我们首先输入列索引，然后输入行索引。  让我们把它分解成几个步骤：

 我们首先选择一个列索引（字母）。  这对应于包含该列的所有观察值的列表（系列）。  Excel与规范框架一致；  电子表格作为按字母索引的列的集合。

 然后，我们选择一个行索引（数字）来获得特定的观察结果。  重要的是，所有列共享相同的索引方法。  如果第 5 行的日期为 2020 年 1 月 15 日，则所有列的第 5 行都有 2020 年 1 月 15 日的数据。Excel 行索引也与规范框架一致。

### Pandas: Series 和 Indices

Pandas，除其他外，允许您有效地处理表格格式的数据。  在 Pandas 中，表格数据符合我们的规范表示：

熊猫数据框是系列的集合。  列索引将每个列标签映射到其对应的系列。

每个系列代表一个一维数据元素数组。  行索引（在 Pandas 中简称为索引）将行标签映射到它们对应的数据元素

要将 Pandas 引入我们的项目，我们需要确保已安装包。  然后，我们需要将 Pandas 包导入到我们的 Python 源代码中。  pandas 普遍接受的快捷方式是 pd：

~~~
import pandas as pd 
~~~

#### 构建 Series 对象

为了更好地理解 Pandas 中的 Series 对象，让我们回到之前的示例，即使用列表计算 Qantas 每周平均股票价格。 我们使用两个单独的列表来维护日期和价格数据，并通过索引日期列表来访问对应的价格数据。使用 Series，我们可以将这两个列表组合成一个对象，从而消除了需要不断检查两个列表是否同步的麻烦。

具体而言，我们使用 Pandas 中的 Series 构造函数来创建一个 Series 对象。这个构造函数是 Pandas 模块的一部分，我们通常将其导入为 pd。构造函数的参数有很多，但在本文中，我们只需要关注数据和索引这两个参数即可。如果需要，可以在 Pandas 的官方文档中查看构造函数的完整参数列表。

在 lec_pd_series.py 模块中，我们有：

~~~
# ---------------------------------------------------------------------------- 
#   Create a Series instance
# ---------------------------------------------------------------------------- 
# Create a series object
ser = pd.Series(data=prices, index=dates)
print(ser)
~~~

输出为：

~~~# Output:
# Output:
#  2020-01-02    7.16
#  2020-01-03    7.19
#  2020-01-06    7.00
#  2020-01-07    7.10
#  2020-01-08    6.86
#  2020-01-09    6.95
#  2020-01-10    7.00
#  2020-01-13    7.02
#  2020-01-14    7.11
#  2020-01-15    7.04
#  dtype: float64
~~~

在前面的文本中，我们提到了 Series 是一个一维数组对象，其中包含了索引和对应的数据。当使用print输出Series对象时，输出结果显示了两列。第一列是索引，第二列是数据数组。这是因为Pandas Series对象保证索引和数据始终同步，但是我们仍然可以单独查看它们。与Excel电子表格中的列类似，Series是可索引的。因此，在Series构造函数中必须指定数据和索引这两个参数。数据参数是一个对象，通常是一个列表，包含我们感兴趣的主要数据。索引参数是一个列表或类似列表的对象，包含数据的行索引标签。如果使用字典作为数据，则有两种选择：要将字典键用作索引并将值用作数据，只需将字典提供给数据参数并指定index=None；如果您希望用不同的索引方法替换键，请提供一个新的索引列表作为索引参数。通过将数据和索引组合成一个对象，我们可以直接通过索引标签选择单个数据元素。

~~~~
# This is the series we created above
ser = pd.Series(data=prices, index=dates)

# Select Qantas price on '2020-01-02' ($7.16) using ...

# ... the `prices` list
prc0 = prices[dates.index('2020-01-02')]    
print(prc0)                                 

# ... the `ser` series
prc1 = ser['2020-01-02']            
print(prc1)           
~~~~

#### 选择元素：简介

Pandas 提供了多种从 Series 中选择元素的方法，其中包括使用中括号 [] 进行索引。可以使用 [] 来选择切片，类似于我们在之前的列表中所做的操作。例如，要选择 2020 年 1 月第二周的收盘价：

~~~
# ---------------------------------------------------------------------------- 
#   Slicing series
# ---------------------------------------------------------------------------- 
# Unlike dictionaries, you can slice a series
prcs = ser['2020-01-06':'2020-01-10']

print(prcs)

# Output:
#  2020-01-06    7.00
#  2020-01-07    7.10
#  2020-01-08    6.86
#  2020-01-09    6.95
#  2020-01-10    7.00
#  dtype: float64    
~~~

与list做对比：

~~~
# Using the lists:
prices[dates.index('2020-01-06'):dates.index('2020-01-10')+1]
~~~

该比较强调了 Series 相对于列表的三个优势：

首先，使用 Pandas Series 对象的索引标签进行切片操作比使用列表和日期索引进行切片操作更简洁。例如，ser['2020-01-06':'2020-01-10'] 相对于 prices[dates.index('2020-01-06'):dates.index('2020-01 -10')+1] 更加简洁。

其次，Series 切片操作包含端点，而 List 切片操作不包含端点。因此，对于 Series 切片，我们只需要指定开始和结束的索引标签，不需要在最后一个观察值后添加 1 作为结束索引。而对于列表切片，我们需要记住不包含端点的规则，并将一个添加到我们的结束索引。

第三，尽管这并不明显，但是 Series 对象的内部操作使得它们在处理大量数据时更加高效。

#### Series 的属性

Series 是一种强大而灵活的数据结构，因为它们不是简单地将数据和索引存储到 Python 列表中，而是使用值列表和索引列表来创建专门的索引容器。 Series 可以被视为一维数组对象，其中包含一组值和将数据标签与每个值相关联的索引。我们可以使用属性来访问这些组件，例如 `array` 属性可以提供系列中的数据。

~~~
# This is the series we created above
ser = pd.Series(data=prices, index=dates)

# Use `.array` to get the underlying data array
ary = ser.array
print(ary)

# Output:
#  <PandasArray>
#  [7.16, 7.19, 7.0, 7.1, 6.86, 6.95, 7.0, 7.02, 7.11, 7.04]
#  Length: 10, dtype: float64
#  

# Like any instance, you can get its type (i.e., the class used to create the
# instance)
type(ser.array)

# Output:
#  <class 'pandas.core.arrays.numpy_.PandasArray'>
~~~

与之前的描述相同，Series不是将值存储在Python列表或元组中，而是使用特定的方式存储索引和值，因此调用Series对象的`.array`属性不能返回列表对象。相反，它返回一个PandasArray对象，这些数组将在后面的学习中进一步讨论。可以将其视为具有特定顺序和固定大小的元组的特殊版本。我们可以通过`index`属性访问索引，使用点语法调用属性即可，与之前访问`.array`相同。

~~~
# Create a series object
ser = pd.Series(data=prices, index=dates)

# Use the `index` attribute to get the index from a series
the_index = ser.index
print(the_index)

# Output:
# Index(['2020-01-02', '2020-01-03', '2020-01-06', '2020-01-07', '2020-01-08',
#    '2020-01-09', '2020-01-10', '2020-01-13', '2020-01-14', '2020-01-15'],
#   dtype='object')


# Like any instance, you can get its type (i.e., the class used to create the
# instance).
print('The type of `the_index` is', type(the_index)) 

# Output:
# The type of `the_index` is <class 'pandas.core.indexes.base.Index'>
~~~



## Pandas DataFrames

Pandas的DataFrame是一个类似于电子表格的对象，其中包含了列和索引的集合。和电子表格一样，DataFrame对象也有三种类型的信息：数据（即列的集合）、列索引（即列标签）和行索引（即行标签）。我们可以将DataFrame看作是一组Series，其中每个Series都具有相同的行标签（即相同的索引）。DataFrame中的列索引将每个Series与其列标签相关联，而行索引则标识了DataFrame中任何Series中的元素。可以通过属性索引来访问这个公共的行索引。

### 构建 DataFrames

让我们从创建 Pandas DataFrame 的基本方法开始。我们可以通过创建单独的 Pandas Series，然后将它们组合成一个数据框来创建 DataFrame。在 lec_pd_dataframes.py 模块中，我们可以看到我们首先创建了两个 Pandas Series。第一个叫做 prc_ser，包含 Qantas 公司在 2020 年前十个交易日的收盘价格。第二个 Pandas Series 叫做 bday_ser，仅是同期每个交易日的计数器。换句话说，在 1 月 2 日它的值为 1，在 1 月 3 日它的值为 2，以此类推。

~~~
# Series with prices
prc_ser = pd.Series(data=prices, index=dates)

# Series with trading day
bday_ser = pd.Series(data=bday, index=dates)
~~~

请注意，数据框中每个系列都有完全相同的索引，由日期组成。

数据框可以视为一系列对象的标记集合，每个对象都是一个系列（列）。可以通过列标签访问数据框中的每个系列，就像在字典中访问键值一样。实际上，可以通过将系列字典传递给 pd.DataFrame 构造函数来创建数据框，其中字典的键成为数据框中列的索引标签。将以下内容添加到 lec_pd_dataframes.py：

~~~
# Using the series we created above...

# Data Frame with close and Bday columns
df = pd.DataFrame({'Close': prc_ser, 'Bday': bday_ser})

print(df)
# Output:
#             Close  Bday
# 2020-01-02   7.16     1
# 2020-01-03   7.19     2
# 2020-01-06   7.00     3
# 2020-01-07   7.10     4
# 2020-01-08   6.86     5
# 2020-01-09   6.95     6
# 2020-01-10   7.00     7
# 2020-01-13   7.02     8
# 2020-01-14   7.11     9
# 2020-01-15   7.04    10
~~~

DataFrame 就像一个电子表格，可以通过列和行的标签来访问其中的数据元素。与 Excel 中的电子表格不同，DataFrame 中的列标签可以是任意的字符串，而行标签则使用相同的索引来标识每个系列中的位置。需要注意的是，列和行标签不是数据的一部分，而是用来标识数据的位置。可以使用 DataFrame 构造函数创建数据框，可以将系列以字典的形式作为参数传递给构造函数。

~~~
other_dates = [
  '2020-01-06',
  '2020-01-07',
  '2020-01-08',
  '2020-01-09',
  '2020-01-10',
  '2020-01-13',
  '2020-01-14',
  '2020-01-15',
  '2020-01-16',
  '2020-01-17',
  ]
other_bday = [
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        ]
new_bday_ser = pd.Series(data=other_bday, index=other_dates)
new_df = pd.DataFrame({'Close': prc_ser, 'Bday': new_bday_ser})
print(new_df)
# Returns:
#             Close  Bday
# 2020-01-02   7.16   NaN
# 2020-01-03   7.19   NaN
# 2020-01-06   7.00   3.0
# 2020-01-07   7.10   4.0
# 2020-01-08   6.86   5.0
# 2020-01-09   6.95   6.0
# 2020-01-10   7.00   7.0
# 2020-01-13   7.02   8.0
# 2020-01-14   7.11   9.0
# 2020-01-15   7.04  10.0
# 2020-01-16    NaN  11.0
# 2020-01-17    NaN  12.0
~~~



## 整理排序 Series 和 Dataframes

确保 Series 和 DataFrame 按照索引排序是一种良好的做法。 对于 DataFrame，这意味着行索引已排序，而不是列已排序。 如果数据基于日期，则行索引应按时间顺序排序。 如果您使用整数标识符对行进行标记，则应按升序对整数进行排序。

排序对于正确选择数据非常重要，而选择数据是所有分析的基础。 因此，每次选择数据时，我们需要确保选择的是正确的数据。 在后面学习“在 Pandas 中访问数据：索引”课程时，我们将更加深入地讨论排序的重要性。

尽管排序很重要，但 Pandas 不会自动对所有索引进行排序，因为不断对数据进行排序可能非常耗时。 因此，Pandas 默认将数据添加到序列或数据框的末尾，以便更快地工作。 因此，建议您首先组装您的系列和/或数据框，然后再对它们进行排序，例如添加或删除行、重新标记行或列。 完成这些操作后，在进行实际分析之前对系列和数据框进行排序。

现在，让我们看看如何检查我们的数据是否已排序......

~~~
# Create a series with an unsorted index 
new_ser = pd.Series(data=[1,3,2], index=['a', 'c', 'b']) 

# This will return 'False'
print(new_ser.is_monotonic_increasing) 
~~~

**对 Series 或 DataFrame 进行排序**

~~~
# Sort the series
sorted_ser = new_ser.sort_index()
print(sorted_ser)

# This will return only the first rows (not the entire series as before)
x = sorted_ser['a':'b'] # --> only first two rows
print(x)
# Out:
# a    1
# b    2
# dtype: int64

# `sorted_ser` is sorted so the following will return the intersection between
# the slice and the row labels
x = sorted_ser['b':'z']
print(x)
# Out:
# b    2
# c    3
# dtype: int64
~~~

